#!/usr/bin/php
<?php

/**
 * lingth
 *
 * Identify lines longer than a given character length.
 *
 * This script is essentially just a big wrapper around ./lingth.php. It
 * provides a command-line interface to the function, and supports various
 * options, multiple files, input redirection. Also provides very basic usage.
 */

require_once('lingth.php');

if (php_sapi_name() != "cli") {
    die("cli only");
    return;
}

define('NAME', basename(array_shift($argv)));

define('ERR_BAD_CONFIG', 1);

$opts = read_config();

// Process any command-line options
while (count($argv) && $argv[0][0] == '-') {
    $arg = array_shift($argv);

    for ($ch = 1; $ch < strlen($arg); $ch++) {
        switch ($arg[$ch]) {
            case 'c': $opts['cn'] = false; break;
            case 'H': $opts['fn'] = true; break;
            case 'h': $opts['fn'] = false; break;
            case 'l': $opts['sl'] = false; break;
            case 'm': $opts['lm'] = handle_arg($arg, $argv); break;
            case 'n': $opts['ln'] = false; break;
            case 'p': $opts['tr'] = false; break;
            case 't': $opts['tw'] = handle_arg($arg, $argv); break;
        }
    }
}

if (!array_key_exists('fn', $opts)) {
    $opts['fn'] = count($argv) > 1;
}

// Handle any input piped or redirected here
if (!posix_isatty(STDIN)) {
    $str = stream_get_contents(STDIN);
    $results = check_line_lengths("(standard input)", $str, $opts);
    echo cli_report("(standard input)", $results, $opts);
} else if (count($argv) == 0) {
    die(usage());
}

// Handle filenames passed as parameters
foreach ($argv as $filename) {
    if (($path = realpath($filename)) === false) {
        die(NAME.": $filename: No such file\n");
    } elseif (is_dir($path)) {
        die(NAME.": $filename: Is a directory\n");
    }

    $results = check_line_lengths($filename, file_get_contents($path), $opts);
    echo cli_report($filename, $results, $opts);
}

/**
 * Format line-length results for terminal output
 *
 * Options are as follows:
 *
 * 'fn' boolean FileName; whether or not to output the relevant filename
 * 'ln' boolean Line Number; whether to output the line number of long lines
 * 'sl' boolean Show Length; whether to output the actual length of long lines
 * 'tr' boolean Tab Replace; whether to output spaces instead of tabs
 *
 * @param string $filename Name of file that produced these results
 * @param array $results Results obtained from check_line_lengths()
 * @param array $options Options/flags to control behaviour (see above)
 *
 * @return string Results formatted for terminal output
 */
function cli_report($filename, $results, $options)
{
    $out = "";

    foreach ($results as $result) {
        $line = $result["line"];
    
        if ($options["tr"]) {
            $line = replace_leading_tabs_with_spaces($line, $options["tw"]);
        }

        $out .= ($options['fn'] ? $filename.':' : '')
            .($options['ln'] ? $result['ln'].' ' : '')
            .($options['cn'] ? $line : '')
            .($options['sl'] ? " ".$result["sl"] : '')
            ."\n";
    }

    return $out;
}

/**
 * Get usage string
 * 
 * @return string usage
 */
function usage()
{
    return "Usage: ".NAME
        ." [-H] [-h] [-l] [-m num] [-n] [-p] [-t num] <file> ...\n"
        ."    -c      don't show content\n"
        ."    -H      show filenames\n"
        ."    -h      don't show filenames\n"
        ."    -l      don't show length\n"
        ."    -m num  set length limit\n"
        ."    -n      don't show line numbers\n"
        ."    -p      don't replace tabs with spaces\n"
        ."    -t num  set tab width in spaces\n";
}

/**
 * Process a command-line option that requires an argument
 *
 * @param string $arg argument to process
 * @param array $args full list of unprocessed arguments
 * 
 * @return int Argument value
 */
function handle_arg($arg, &$args)
{
    if (strlen($arg) > 2) {
        $argval = substr($arg, 2);
    } elseif (count($args)) {
        $argval = array_shift($args);
    } else {
        die(NAME.": Option requires an argument -- ".$arg[1]."\n");
    }

    if (!is_numeric($argval)) {
        die(NAME.": Invalid argument; must be numeric -- ".$argval."\n");
    }

    return (int)$argval;
}

/**
 * Read configuration from json file. Search locations according to the XDG
 * Base Directory Specification.
 */
function read_config()
{
    $config_dirs = getenv('XDB_CONFIG_DIRS');

    if ($config_dirs === false) {
        $config_dirs = array('/etc/xdg');
    } else {
        $config_dirs = explode(':', $config_dirs);
    }

    $config_home = getenv('XDG_CONFIG_HOME');

    if ($config_home === false) {
        $config_home = getenv('HOME').'/.config';
    }

    $config_dirs[] = $config_home;

    foreach ($config_dirs as $dir) {
        if (file_exists($file = $dir."/lingth/config.json")) {
            return json_decode(file_get_contents($file), true);
        }
    }

    fwrite(STDERR, "bad error: no config file. install one.\n");
    exit(ERR_BAD_CONFIG);
}
